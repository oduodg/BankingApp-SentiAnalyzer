# -*- coding: utf-8 -*-
"""최종 긍부정 점수 계산.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JmBdWjcteDdDFGy1iUll_W0ZlmCQiXDX

# 1. 코랩 환경 설정

- "#" 표시는 주석을 의미 , 따라서 주석처리한 코드는 코드가 실행되지 않음
"""

# 자기 구글 드라이브랑 연결하는 것
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# 디렉토리 변경

#공유 폴더를 기본 디렉토리로 하는 경우 
#%cd drive/Shareddrives/언어의미와정보 데이터캡스톤디자인 

#내 드라이브를 기본 디렉토리로 하는 경우(일단 저는 제 폴더에 word_dic, user_dic이 있어서 이렇게 설정했습니다!)
# %cd drive/MyDrive/PBL

# 현재 디렉토리 경로 확인
!pwd

"""# 2. 형태소 분석에 필요한 패키지 import"""

pip install konlpy

import pandas as pd
#from PyKomoran import *
from konlpy.tag import Komoran
import sys
import regex
import warnings 
import copy
from tqdm import tqdm

warnings.filterwarnings('ignore')

"""## 사용자 정의 사전 등록"""

#사용자 정의 사전 등록
komoran = Komoran(userdic='user_dictionary.txt')

"""#3. 분석데이터 불러오기"""

Data = {'한국씨티':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/city_spell_checked.csv',
 '하나':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/hana_spell_checked.csv',
 'k뱅크':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/k_spell_checked.csv',
 '카카오':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/kakao_spell_checked.csv',
 'KB':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/kb_spell_checked.csv',
 'NH':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/nh_spell_checked.csv',
 'SC제일':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/sc_spell_checked.csv',
 '신한':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/shinhan_spell_checked.csv',
 '수협':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/sh_spell_checked.csv',
 '토스':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/toss_spell_checked.csv',
 '우리':'/content/drive/Shareddrives/언어의미와정보 데이터캡스톤디자인/2021 리뷰 최종/woori_spell_checked.csv'}

#분석할 리뷰들이 담겨져 있는 데이터 프레임 불러오기
d = input('리뷰 가져올 은행(한국씨티,하나,k뱅크,카카오,KB,NH,SC제일,신한,수협,토스,우리) :')
link = Data[d]
koreanCity_review2021 = pd.read_csv(link)
koreanCity_review2021.head()

# 데이터 전처리 (띄어씌기, 맞춤법, 특수문자 삭제는 패키지로 이미 처리)
#쓸모없는 열 삭제 (Unnamed: 0, userName)
koreanCity_review2021 = koreanCity_review2021.drop(['Unnamed: 0', 'userName'], axis = 1) 

# 리뷰 글자 수가 10개 미만 인 리뷰는 신뢰성이 떨어지므로 제외
koreanCity_review2021 = koreanCity_review2021.loc[[i for i in range(len(koreanCity_review2021['comment'])) if len(koreanCity_review2021['comment'][i]) >= 10]]

#인덱스 초기화
koreanCity_review2021 = koreanCity_review2021.reset_index(drop=True)

koreanCity_review2021.head() #가장 위에 5개 행 출력

koreanCity_review2021.tail() #가장 아래 5개 행 출력

print(d+' 어플의 리뷰 개수 :',len(koreanCity_review2021))

"""#4. 점수 산출과정에서 필요한 함수 정의

- Seperator_part : 한문장을 넣으면 형태소분석결과 리턴해주는 함수
"""

## Seperator_part(한문장)
##한 문장에 대해 형태소 분석하고 (단어, 품사) 형태로 결과를 리턴해주는 함수

def Seperator_part(oneL):
  # slash_line = komoran.get_list(oneL)
  slash_line = komoran.pos(oneL)

  # # (단어,품사) 형태로 만들기
  # tagged_list = []
  # for i in range(len(slash_line)):
  #     a = str(slash_line[i]).split('/')
  #     tagged_list.append(a)

  # for j in tagged_list:
  #     if len(j) != 2:
  #         tagged_list.remove(j)

  #return tagged_list
  return slash_line

"""- remove_word_by_tag : 형태소 분석결과(단어,품사)를 넣으면 점수계산할 때 필요한 태그만 리턴해주는 함수"""

# 고려하지 않는 태그는 버리는 함수
def remove_word_by_tag(x):
    temp = list()
    tag_list = ['NNG','NNP','VCP','VCN','VV', 'VA', 'MAG','NR','IC','XR','VX', 'ETM', 'ETN', 'EC', 'JKS'] #고려하는 태그 목록
    for k in range(len(x)):
        if x[k][1] in tag_list:
            temp.append(x[k])
        else:
            continue
    return temp

"""- bring_dic2 : 감성사전 가져오는 함수"""

# 점수 사전 가져와서 dataframe으로 저장하는 함수 (우리가 직접 만든 사전 활용하는 ver)
def bring_dic2():
  df = pd.read_csv("word_dic.csv")
  return df

"""- bring_word_score2 : 감성사전에서 원하는 단어 점수 리턴하는 함수, 감성사전에 없는 단어(=점수매기지 않은 단어들)는 기본으로 reinforcer 1값, score 0값 리턴함"""

# 단어 점수 가져오는 함수(기본 0,1값 가지는 ver)
def bring_word_score2(w, t, dic, score_type=True):
  temp = dic.loc[(dic['WORD'] == w) & (dic['TAG'] == t)]

  if temp.empty != True :
    if score_type:
      score = float(temp['score'].unique())
      return dic, score

    else:
      rein = float(temp['reinforcer'].unique())
      return dic, rein

  #점수 등록이 안되어 있을 때
  else:
    temp = dic.loc[dic['WORD'] == w]
    if temp.empty == True :
      #defualt
      new_score = 0
      new_rein = 1

      if score_type == True:
        return dic, new_score

      else:
        return dic, new_rein

    else:
      if score_type:
        score = float(temp['score'].unique())
        return dic, score

      else:
        rein = float(temp['reinforcer'].unique())
        return dic, rein

"""- seperator_sentence_final : 한 문장을 넣으면 이어진 문장들로 분리해주는 함수"""

##이어진 문장쪼개기
# 1. SF, SP 기준으로 쪼개기 -> 2. EC, EF 기준으로 쪼개기 -> 3. jks/jx+...+etn으로 쪼개기
def seperator_sentence_final(s):
  ls = Seperator_part(s)
  #print('원문장: ',ls)

  stack = [] #쪼개지는 조건 만날 때 까지 계속 쌓임
  final_ls = [] #쪼개져서 묶여진 형태가 쌓이는 스택

  J_in = False

  for k in range(len(ls)):
    if ls[k][1] in ['SF', 'SP']:
      #쪼개기
      final_ls.append(stack)
      stack = []


    elif ls[k][1] in ['EC', 'EF']:
      #쪼개기
      stack.append(ls[k])
      final_ls.append(stack)
      stack = []

    elif ls[k][1] in ['JKS', 'JX']:
      J_in = True
      stack.append(ls[k])
      continue;
    
    elif ls[k][1] == 'ETN':
      if J_in:
        stack.append(ls[k])
        final_ls.append(stack)
        stack = []
        J_in = False

      else:
        stack.append(ls[k])
    
    else:
      stack.append(ls[k])

  if stack:
    final_ls.append(stack)

    #SP,SF로 나눈 경우 앞에 이미 EC나 EF 기준으로 나누어 지게되면 빈 리스트가 final_ls에 추가되게 됨 
    #따라서 최종적으로 빈 리스트 있는 경우는 빈 리스트 삭제
    while [] in final_ls:    
	    final_ls.remove([]) # 빈 리스트([]) 삭제
    
    return final_ls

  else:
    while [] in final_ls:    
	    final_ls.remove([]) # 빈 리스트([]) 삭제

    return final_ls

"""- Calculator_review : 리뷰(여러개 넣어도 됨)에 대한 점수 계산 식을 print해주는 함수"""

def Calculator_review (reviews, df):
    #덧셈품사
    plus_pumsa = ['NNG', 'NNP', 'NR', 'IC', 'XR', 'VCN', 'VCP']
    
    #곱셈품사
    mul_pumsa = ['VV', 'MAG', 'VX']
    
    #기타품사
    etc_pumsa = ['JKS', 'ETM', 'ETN', 'EC']
    
    continue_num = 1  # 2* 이런식으로 끊기는 거 (VA+EC->MAG)
    review_score = [] #최종 데이터 프레임 열로 들어갈 리스트
    if len(reviews) == 1:
        reviews = list(reviews)
    
    for munzang in tqdm(reviews):
    
      Final_cal_SUM = [] #이어진 문장 계산 식 싹 다 통합하는 리스트
    
      print()
      print('리뷰원문:', munzang)
      tagged_list =  seperator_sentence_final(munzang)  #이어진 문장 쪼개기
      #SUM = 0
      #Final_cal_SUM = [] #이어진문장 개별 점수값 담는 리스트(나중에 이 리스트에 담긴 숫자들 모두 합치는 식으로 최종점수산출)
    
      for mun in tagged_list:
        final_mul = 1
        tl = remove_word_by_tag(mun)
    
        # print()
        # print('형태소 분석 결과 :', mun)
        
        #print('평가 대상: ', tl)
        #print()
        
        # 쪼갠 단어에 대해 단어리스트, 형태소 리스트 생성
        munzang_pumsa = []
        munzang_word = []
        filter_pumsa = []
        filter_word = []
    
        for i in range(len(mun)):
          munzang_pumsa.append(mun[i][1])
          munzang_word.append(mun[i][0])
    
        for i in range(len(tl)):
          filter_pumsa.append(tl[i][1])
          filter_word.append(tl[i][0])
    
        #print('쪼개진 품사 형태 :', munzang_pumsa)
        #print('쪼개진 단어 형태 :', munzang_word)
        #print()
        #print('걸렀을 때 품사 형태 :', filter_pumsa)
        #print('걸렀을 때 단어 형태 :', filter_word)
        #print()
    
        cal_ls = []
        length = 0
    
        if continue_num != 1:
          cal_ls.append(continue_num)
          cal_ls.append('*') 
    
          continue_num = 1 #continue_num 초기화
    
        #######cal_ls 에 계산식 쌓기######
        #거른 품사 형태 리스트에서 하나씩 해당하는 품사 볼꺼임
        for p in filter_pumsa:
          length += 1
          #print('반복횟수 :', length)
          
          #기타 품사인 경우 (JKS, ETM, ETN, EC)
          if p in etc_pumsa:
            continue;
    
          #VA인 경우
          elif p == 'VA':
            # VA + ETM + NNP -> VA * NNP
            if (len(filter_pumsa[length-1:]) >= 3) and (filter_pumsa[length] == 'ETM') and ((filter_pumsa[length+1] == 'NNP') or (filter_pumsa[length+1] == 'NNG')):
              df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
              cal_ls.append(score_num)
              cal_ls.append('*')
    
            # NNP + VA -> NNP*VA
            elif (len(filter_pumsa[:length-1]) >= 1) and ((filter_pumsa[length-2] == 'NNP') or (filter_pumsa[length-2] == 'NNG')) :
              cal_ls.pop()
              cal_ls.append('*')
              df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
              cal_ls.append(score_num)
    
              #끝이 아니면 +로 연결 ('JKS', 'ETM', 'ETN', 'EC')
              if length != len(filter_pumsa):
                for i in filter_pumsa[length:]:
                  if i in etc_pumsa:
                    continue;
                  else:
                    cal_ls.append('+')
                    break;
    
            # VA+(게-EC) -> VA->MAG로 바꿈
            elif (len(filter_pumsa[length-1:])>=2) and (filter_pumsa[length] == 'EC') and (filter_word[length] == '게'):
              df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
              cal_ls.append(score_num)
              cal_ls.append('*')
    
            # 위 3가지 조건에 모두 걸리지 않으면 덧셈점수가짐
            else:
              df, score_num = bring_word_score2(filter_word[length-1], p, df)
              cal_ls.append(score_num)
              
              if length != len(filter_pumsa):
                for i in filter_pumsa[length:]:
                  if i in etc_pumsa:
                    continue;
                  else:
                    cal_ls.append('+')
                    break;
    
    
          #VA가 아닌 덧셈품사 인 경우
          if p in plus_pumsa:
            df, score_num = bring_word_score2(filter_word[length-1], p, df) 
    
            #덧셈품사 앞에 곱하기 있을 때 덧셈품사가 중성(0값)이고 곱셈품사가 중성이 아닐때(!=1) 1값이 앞의 곱셈품사와 곱해짐
            if (length != 1) and (len(cal_ls) >= 2) and (cal_ls[-1] == '*') and (score_num == 0) and (cal_ls[-2] != 1):
              score_num += 1 
    
            cal_ls.append(score_num)
            
            if length != len(filter_pumsa):
              for i in filter_pumsa[length:]:
                  if i in etc_pumsa:
                    continue;
                  else:
                    cal_ls.append('+')
                    break;
    
          #VA가 아닌 곱셈품사 인 경우
          if p in mul_pumsa:
            # VV가 아닌 경우
            if p != 'VV':
              df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
              cal_ls.append(score_num)
              if length != len(filter_pumsa):
                for i in filter_pumsa[length:]:
                  if i in etc_pumsa:
                    continue;
                  else:
                    cal_ls.append('*')
                    break;
    
            # VV인 경우
            else :
              #VV가 맨 끝에 있는 경우 전체 점수값에 곱함
              if length == len(filter_pumsa):
                cal_ls.append(')')
                cal_ls.append('*')
                df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
                cal_ls.append(score_num)
    
              elif length != len(filter_pumsa):
                for i in filter_pumsa[length:]:
                  bottom = True
                  #VV가 맨 끝이 아니면
                  if i not in etc_pumsa:
                    bottom = False
                    df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
                    cal_ls.append(score_num)
                    cal_ls.append('*')
                    break;
                #VV가 맨 끝이면 
                if(bottom):
                  cal_ls.append(')')
                  cal_ls.append('*')
                  df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
                  cal_ls.append(score_num)    
    
        #print('stack :', cal_ls)
        #print()
        cal_num_stack = []
        final_mul = 1
        #mul_last = False
    
        try:
          for i in range(len(cal_ls)):
            #stack에 안쌓이는 경우
            if cal_ls[i] == '+':
              continue;
            elif cal_ls[i] == ')':
              continue;
            elif (i != 0) and (type(cal_ls[i]) != str) and (cal_ls[i-1] == '*') :
              continue;
    
            elif cal_ls[i] == '*':
              #전체 점수에 강화점수 곱해지는 경우
              if cal_ls[i-1] == ')':
                if i == 1: # )* 가 맨 처음에 등장하는 경우 = VV가 맨 처음이자 마지막인 경우 
                  cal_num_stack.append(cal_ls[i+1])
                else:
                  final_mul *= cal_ls[i+1]
    
              #전체에 곱해지는 경우 X
              elif i != len(cal_ls)-1:  # 마지막 곱하기가 아니면
                num1 = cal_num_stack.pop()
                num2 = cal_ls[i+1]
    
                # * ) * 인 경우
                if num2 == ')' :
                  final_mul = num1
                  continue
    
    
                #(1이 아닌)강화값 * 중성값이면 중성값이 1값 가짐
                elif (num1 != 1) and (num2 == 0):
                  num2 = 1
    
                result = num1 * num2
                cal_num_stack.append(result)
    
              else: #맨 마지막에 곱하기 문자 나타남(VA+EC 인 경우)
                continue_num = cal_num_stack.pop()  #cal_num_stack에 담겨져 있는 VA 삭제
                break;
    
    
            # 숫자면 스택에 쌓임
            else:
              cal_num_stack.append(cal_ls[i])
    
            #print('스택상태 :', cal_num_stack)
    
        except:
          print('*'*100)
          print('계산할 수 없는 식입니다!!!!!!!')
          print('*'*100)
          print()
          continue
    
        #계산
        #print('-'*50)
        print("계산식 =", " ".join(list(map(str, cal_ls))))
    
        sum_score = sum(cal_num_stack)
    
        #강화품사만으로 구성된 경우 -> 문장 점수를 갖지 않고 이전 문장 점수의 강화자 점수를 가짐 
        if (len(cal_num_stack) <= 1) and (len([i for i in filter_pumsa if (i in plus_pumsa) or (i == 'VA')]) == 0):
          # 앞의 문장점수에 곱하기
          if len(Final_cal_SUM) != 0:
            previous_score = Final_cal_SUM.pop()  # 강화품사로만 구성된 문장이 맨 앞이다 -> 0값 가짐
    
            if len(cal_num_stack) == 1:
              if previous_score == 0 and sum_score != 1:
                previous_score += 1  # 앞 문장이 중성이고 곱하는 값은 중성이 아닌 경우 중성문장 점수값 0->1 
              
              Final_cal_SUM.append(previous_score*sum_score)
              #다른 문장 강화하는데 점수 소비했기 때문에 최종 점수 값 싹 다 초기화
              sum_score = 0
              final_mul = 1
    
            else: # 3*)*2 
              if previous_score == 0 and final_mul != 1:
                previous_score += 1
    
              Final_cal_SUM.append(previous_score*final_mul)
              #다른 문장 강화하는데 점수 소비했기 때문에 최종 점수 값 싹 다 초기화
              sum_score = 0
              final_mul = 1
    
        elif (sum_score == 0) and (final_mul != 1):
          sum_score = 1
    
        final_score = sum_score * final_mul
        
        #print('계산결과 :',final_score)
        #print('-'*20)
    
        Final_cal_SUM.append(final_score)
    
      print('최종 계산식 :',  "+".join(list(map(str, Final_cal_SUM))))
      Final_score = sum(Final_cal_SUM)
      review_score.append(Final_score)
      print('최종 계산결과 :', Final_score)
      #print('-'*50)
      #print()

    return review_score

"""# 문장 넣고 (단어, 품사) 형태 보기"""

Seperator_part('너무 잘 만든 것 같습니다')

"""#5. 리뷰점수산출

- 구축한 감성사전 가져오기
"""

# 긍/부정 사전 가져오기 (단어, 품사, 강화값, 덧셈값) 형태
df = bring_dic2() 
df.head()

df.tail()

"""- 리뷰 최종 점수 구하기

# 점수계산 함수 사용 예시

- 함수 사용(ver)
"""

#Calculator_review함수 사용 시 문장 한개에 대해서 보려면 반드시 []리스트 안에 넣은 형태로 넣기!
#점수 사전 미리 정의하여 매개변수로 넣어야 함!(df)
Calculator_review(['디자인도 너무 예쁘고 사용하기도 편리해요'], df)

"""# 어플 리뷰 전체 점수 계산 코드"""

#덧셈품사
plus_pumsa = ['NNG', 'NNP', 'NR', 'IC', 'XR', 'VCN', 'VCP']

#곱셈품사
mul_pumsa = ['VV', 'MAG', 'VX']

#기타품사
etc_pumsa = ['JKS', 'ETM', 'ETN', 'EC']

continue_num = 1  # 2* 이런식으로 끊기는 거 (VA+EC->MAG)
review_score = [] #최종 데이터 프레임 열로 들어갈 리스트

for munzang in tqdm(koreanCity_review2021['comment']):
  
  Final_cal_SUM = [] #이어진 문장 계산 식 싹 다 통합하는 리스트

  #print('-'*50)
  print('리뷰원문:', munzang)
  tagged_list =  seperator_sentence_final(munzang)  #이어진 문장 쪼개기
  #SUM = 0
  #Final_cal_SUM = [] #이어진문장 개별 점수값 담는 리스트(나중에 이 리스트에 담긴 숫자들 모두 합치는 식으로 최종점수산출)

  for mun in tagged_list:
    final_mul = 1
    tl = remove_word_by_tag(mun)

    # print()
    #print('형태소 분석 결과 :', mun)
    
    #print('평가 대상: ', tl)
    #print()
    
    # 쪼갠 단어에 대해 단어리스트, 형태소 리스트 생성
    munzang_pumsa = []
    munzang_word = []
    filter_pumsa = []
    filter_word = []

    for i in range(len(mun)):
      munzang_pumsa.append(mun[i][1])
      munzang_word.append(mun[i][0])

    for i in range(len(tl)):
      filter_pumsa.append(tl[i][1])
      filter_word.append(tl[i][0])

    #print('쪼개진 품사 형태 :', munzang_pumsa)
    #print('쪼개진 단어 형태 :', munzang_word)
    #print()
    #print('걸렀을 때 품사 형태 :', filter_pumsa)
    #print('걸렀을 때 단어 형태 :', filter_word)
    #print()

    cal_ls = []
    length = 0

    if continue_num != 1:  #이어진 문장에서 전에 문장이 VA+EC형태로 끝나서 -> MAG로 취급되는 경우
      cal_ls.append(continue_num)
      cal_ls.append('*') 

      continue_num = 1 #continue_num 초기화

    #######cal_ls 에 계산식 쌓기######
    #거른 품사 형태 리스트에서 하나씩 해당하는 품사 볼꺼임
    for p in filter_pumsa:
      length += 1
      #print('반복횟수 :', length)
      
      #기타 품사인 경우 (JKS, ETM, ETN, EC)
      if p in etc_pumsa:
        continue;

      #VA인 경우
      elif p == 'VA':
        # VA + ETM + NNP -> VA * NNP
        if (len(filter_pumsa[length-1:]) >= 3) and (filter_pumsa[length] == 'ETM') and ((filter_pumsa[length+1] == 'NNP') or (filter_pumsa[length+1] == 'NNG')):
          df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
          cal_ls.append(score_num)
          cal_ls.append('*')

        # NNP + VA -> NNP*VA
        elif (len(filter_pumsa[:length-1]) >= 1) and ((filter_pumsa[length-2] == 'NNP') or (filter_pumsa[length-2] == 'NNG')) :
          cal_ls.pop()
          cal_ls.append('*')
          df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
          cal_ls.append(score_num)

          #끝이 아니면 +로 연결 ('JKS', 'ETM', 'ETN', 'EC')
          if length != len(filter_pumsa):
            for i in filter_pumsa[length:]:
              if i in etc_pumsa:
                continue;
              else:
                cal_ls.append('+')
                break;

        # VA+(게-EC) -> VA->MAG로 바꿈
        elif (len(filter_pumsa[length-1:])>=2) and (filter_pumsa[length] == 'EC') and (filter_word[length] == '게'):
          df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
          cal_ls.append(score_num)
          cal_ls.append('*')

        # 위 3가지 조건에 모두 걸리지 않으면 덧셈점수가짐
        else:
          df, score_num = bring_word_score2(filter_word[length-1], p, df)
          cal_ls.append(score_num)
          
          if length != len(filter_pumsa):
            for i in filter_pumsa[length:]:
              if i in etc_pumsa:
                continue;
              else:
                cal_ls.append('+')
                break;


      #VA가 아닌 덧셈품사 인 경우
      if p in plus_pumsa:
        df, score_num = bring_word_score2(filter_word[length-1], p, df) 

        #덧셈품사 앞에 곱하기 있을 때 덧셈품사가 중성(0값)이고 곱셈품사가 중성이 아닐때(!=1) 1값이 앞의 곱셈품사와 곱해짐
        if (length != 1) and (len(cal_ls) >= 2) and (cal_ls[-1] == '*') and (score_num == 0) and (cal_ls[-2] != 1):
          score_num += 1 

        cal_ls.append(score_num)
        
        if length != len(filter_pumsa):
          for i in filter_pumsa[length:]:
              if i in etc_pumsa:
                continue;
              else:
                cal_ls.append('+')
                break;

      #VA가 아닌 곱셈품사 인 경우
      if p in mul_pumsa:
        # VV가 아닌 경우
        if p != 'VV':
          df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
          cal_ls.append(score_num)
          if length != len(filter_pumsa):
            for i in filter_pumsa[length:]:
              if i in etc_pumsa:
                continue;
              else:
                cal_ls.append('*')
                break;

        # VV인 경우
        else :
          #VV가 맨 끝에 있는 경우 전체 점수값에 곱함
          if length == len(filter_pumsa):
            cal_ls.append(')')
            cal_ls.append('*')
            df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
            cal_ls.append(score_num)

          elif length != len(filter_pumsa):
            for i in filter_pumsa[length:]:
              bottom = True
              #VV가 맨 끝이 아니면
              if i not in etc_pumsa:
                bottom = False
                df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
                cal_ls.append(score_num)
                cal_ls.append('*')
                break;
            #VV가 맨 끝이면 
            if(bottom):
              cal_ls.append(')')
              cal_ls.append('*')
              df, score_num = bring_word_score2(filter_word[length-1], p, df, False)
              cal_ls.append(score_num)    

    #print('stack :', cal_ls)
    #print()
    cal_num_stack = []
    final_mul = 1
    #mul_last = False

    try:
      for i in range(len(cal_ls)):
        #stack에 안쌓이는 경우
        if cal_ls[i] == '+':
          continue;
        elif cal_ls[i] == ')':
          continue;
        elif (i != 0) and (type(cal_ls[i]) != str) and (cal_ls[i-1] == '*') :
          continue;

        elif cal_ls[i] == '*':
          #전체 점수에 강화점수 곱해지는 경우
          if cal_ls[i-1] == ')':
            if i == 1: # )* 가 맨 처음에 등장하는 경우 = VV가 맨 처음이자 마지막인 경우 
              cal_num_stack.append(cal_ls[i+1])
            else:
              final_mul *= cal_ls[i+1]

          #전체에 곱해지는 경우 X
          elif i != len(cal_ls)-1:  # 마지막 곱하기가 아니면
            num1 = cal_num_stack.pop()
            num2 = cal_ls[i+1]

            # * ) * 인 경우
            if num2 == ')' :
              final_mul = num1
              continue


            #(1이 아닌)강화값 * 중성값이면 중성값이 1값 가짐
            elif (num1 != 1) and (num2 == 0):
               num2 = 1

            result = num1 * num2
            cal_num_stack.append(result)

          else: #맨 마지막에 곱하기 문자 나타남(VA+EC(-게) 인 경우)
            continue_num = cal_num_stack.pop()  #cal_num_stack에 담겨져 있는 VA 삭제
            break;


        # 숫자면 스택에 쌓임
        else:
          cal_num_stack.append(cal_ls[i])

        #print('스택상태 :', cal_num_stack)

    except:
      #print('*'*100)
      #print('계산할 수 없는 식입니다!!!!!!!')
      #print('*'*100)
      #print()
      continue

    #계산
    #print('-'*50)
    print("계산식 =", " ".join(list(map(str, cal_ls))))

    sum_score = sum(cal_num_stack)

    #강화품사만으로 구성된 경우 -> 문장 점수를 갖지 않고 이전 문장 점수의 강화자 점수를 가짐 
    if (len(cal_num_stack) <= 1) and (len([i for i in filter_pumsa if (i in plus_pumsa) or (i == 'VA')]) == 0):
      # 앞의 문장점수에 곱하기
      if len(Final_cal_SUM) != 0:
        previous_score = Final_cal_SUM.pop()  # 강화품사로만 구성된 문장이 맨 앞이다 -> 0값 가짐

        if len(cal_num_stack) == 1:
          if previous_score == 0 and sum_score != 1:
            previous_score += 1  # 앞 문장이 중성이고 곱하는 값은 중성이 아닌 경우 중성문장 점수값 0->1 
          
          Final_cal_SUM.append(previous_score*sum_score)
          #다른 문장 강화하는데 점수 소비했기 때문에 최종 점수 값 싹 다 초기화
          sum_score = 0
          final_mul = 1

        else: # ex) 3*)*2 
          if previous_score == 0 and final_mul != 1:
            previous_score += 1

          Final_cal_SUM.append(previous_score*final_mul)
          #다른 문장 강화하는데 점수 소비했기 때문에 최종 점수 값 싹 다 초기화
          sum_score = 0
          final_mul = 1

    elif (sum_score == 0) and (final_mul != 1):
      sum_score = 1

    final_score = sum_score * final_mul
    
    #print('계산결과 :',final_score)
    #print('-'*20)

    Final_cal_SUM.append(final_score)

  print('최종 계산식 :',  "+".join(list(map(str, Final_cal_SUM))))
  Final_score = sum(Final_cal_SUM)
  review_score.append(Final_score)
  print('최종 계산결과 :', Final_score)
  #print('-'*50)
  #print()

#print(len(review_score))

# 계산 결과가 잘 저장되었는지 확인
review_score[:5]

view_df = koreanCity_review2021
view_df['review score'] = review_score
#csv파일로 저장
view_df.to_csv('수협_result.csv', encoding='utf-8-sig')  #파일 제목 변경해주세요!! (저장 파일은 앞에서 설정한 디렉토리 경로에 저장됩니다!)
view_df.head()
# for k in range(len(view_df)):
#   print(view_df['comment'][k])
#   print('별점 :', view_df['score'][k])
#   print('리뷰점수 :', view_df['review score'][k])
#   print('-'*100)

"""#6. 계산 신뢰도 산출
- 별점과 최종점수 비교를 통해 산출함
"""

print('평가 리뷰 개수 :', len(view_df))
print('긍정리뷰인데 부정으로 계산된 경우 :', len(view_df[(view_df['score'] >= 4) & (view_df['review score'] < 0)]))
print('부정리뷰인데 긍정으로 계산된 경우 :', len(view_df[(view_df['score'] <= 2) & (view_df['review score'] > 0)]))
print('긍정리뷰인데 0점으로 계산된 경우 :', len(view_df[(view_df['score'] >= 4) & (view_df['review score'] == 0)]))
print('부정리뷰인데 0점으로 계산된 경우 :', len(view_df[(view_df['score'] <= 2) & (view_df['review score'] == 0)]))

errorCount = sum([len(view_df[(view_df['score'] >= 4) & (view_df['review score'] < 0)]),
                len(view_df[(view_df['score'] <= 2) & (view_df['review score'] > 0)]),
                len(view_df[(view_df['score'] >= 4) & (view_df['review score'] == 0)]),
                len(view_df[(view_df['score'] <= 2) & (view_df['review score'] == 0)])])

errorCount = sum([len(view_df[(view_df['score'] >= 4) & (view_df['review score'] < 0)]),
                len(view_df[(view_df['score'] <= 2) & (view_df['review score'] > 0)])])

print('계산 신뢰도 :', (len(koreanCity_review2021)-errorCount)/len(koreanCity_review2021)*100, '%')



